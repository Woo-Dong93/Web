# Node.js란?

- **2009년 Ryan Dahl이 발표한 크롬 브라우저의 V8(자바스크립트 엔진)기반의 자바스크립트 런타임이다.**
  - 런타임 : 프로그래밍 언어가 구동되는 환경
- 단일 쓰레드 이벤트 루프 기반 비동기방식



### 1. Non blocking I/O

- Non blocking : 이전작업이 완료될 때까지 멈추지 않고 다음 작업을 수행하는 패러다임 이다.
  - 즉 비동기로 실행된다는 의미입니다.
- Input과 Output이 관련된 작업(http, Database CRUD, third party api, filesystem) 등의 블로킹 작업들을 백그라운드에서 수행하고, 이를 비동기 콜백함수로 이벤트 루프에 전달하는 것 이라고 한다.



### 2. 이벤트 루프

- Event Loop : **Single-Thread** 기반에서 비동기 메시지를 처리합니다.
- 요청이 들어오면 이벤트 루프가 요청을 Event Queue에 넣고, 들어와 있는 요청들을 이벤트 루프가 순차적으로 Thread Pool에 있는 쓰레드들에게 작업을 할당해주고, 작업이 끝난 이벤트들을 감지하여 해당 콜백을 다시 Event Queue에 집어넣는다고한다.
  - **실제로 요청을 처리하는 이벤트 루프는 싱글 쓰레드이지만 Thread Pool 내부는 여러개의 쓰레드를 사용하여 이벤트 루프가 콜백을 내부에 여러 스레드들에게 요청을 할당해준다.**



### 3. 장점

- 자바스크립트를 동일하게 사용해서 서버단 로직을 처리할 수 있다는게 가장 큰 장점
  - 새로운 언어를 습득하지 않고도 자바스크립트를 활용해 서버기술을 빨리 개발/응용할 수 있습니다.
- 개발이 빠르고 쉽다. 서버 설치부터 화면 띄우는 것까지 금방 처리 됩니다.
- Non-blocking I/O와 단일 스레드 이벤트 루프를 통한 높은 처리 성능
  - 이벤트 기반 비동기방식이라 서버 무리가 적다.
- npm(node package manager)을 통한 다양한 모듈(패키지) 제공



### 4. 단점

- 이벤트 기반 비동기방식이라 서버단 로직이 복잡한 경우 콜백함수의 늪에 빠질 수 있다.
  - 예를 들어, 한번의 요청에 대해 DB에서 조회한 결과값에 따라 다른 로직을 처리해야 하며, 이런 로직이 여러개인 경우 콜백함수 늪 (Callback Hell) 에 빠진다.
- 코드를 순차적으로 실행하는 것이 아니라 비동기 방식으로 이벤트를 보내고, 응답(이벤트)이 오면 처리하는 방식이기 때문에 java 개발을 했던 방식으로 설계하고 프로그래밍하면 큰 문제가 발생한다. 
- 단일 쓰레드(Single Thread)이기 때문에 하나의 작업 자체가 많이 걸리는 웹서비스에는 어울리지 않다. 
- 코드가 수행되어야 코드에 에러가 있는지 알 수 있으며, 에러가 날 경우 프로세스가 내려가기 때문에 테스트가 엄청 중요하다. 반드시 모든 케이스에 대해 소스코드를 검증해야 한다.



### 5. 어울리는 서비스과 그렇지 않은 서비스

- Node.js 어울리는 서비스
  - 간단한 로직. 
  - 대용량(동시에 여러 request를 처리)
  - 빠른 응답시간 요구
  - 빠른 개발 요구
  - 비동기방식에 어울리는 서비스(네트워크 스트리밍 서비스, 채팅 서비스 등)
- Node.js  어울리지 않은 웹서비스
  - 단일 처리가 오래 걸리는 경우 : 싱글 쓰레드이기 때문
  - 서버 체크로직이 많은 경우 : 비동기방식이기 때문에 CallBack Hell에 빠지지 않기 위해
  - 업무 복잡도/난이도가 높은 경우 : 에러가 나면 서버가 죽기 때문에 코드 품질 중요





# 비교해보기

### 1. 일반 쓰레드 기반 동기방식(Blocking I/O) 

- 즉 하나의 쓰레드가 request를 받으면 모든 처리가 완료될때까지 기다리다가 처리결과가 완료되면 다시 응답을 보냄
- 기존 업무 처리가 왼료되기 전에 또다른 request가 있으면 새로운 쓰레드가 업무를 처리함
- 동시 request가 많으면 쓰레드가 많이 필요하므로 서버 과부하 발생



### 2. 단일 쓰레드 이벤트 루프 기반 비동기 방식( Non-Blocking I/O)

- 하나의 쓰레드가 request를 받으면 바로 다음 처리에 요청을 보내놓고 다른 작업을 처리하다가 먼저 요청한 작업이 끝나면 이벤트를 받아서 응답을 보냅니다.
- 동시 request가 오더라도 처리가 완료될 때 까지 기다리지 않아도 되기 때문에 서버 부하가 적습니다.





### 참고

- https://junspapa-itdev.tistory.com/3
- https://velog.io/@nomadhash/Node-.js-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80