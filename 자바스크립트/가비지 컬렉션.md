# 가비지 컬렉션

- 매모리 관리 기법의 하나로 객체가 생성되었을 때 자동으로 메모리를 할당하고 쓸모 없어졌을 때 자동으로 해제가 됩니다. 이렇게 자동 메모리 관리를 해주는 것이 가비지 컬렉션이라고 알고 있습니다.



### 메모리의 생명주기

- 메모리 할당 : 자바스크립트는 값을 선언할 때마다 자동으로 메모리를 할당합니다.

```javascript
const number = 0;
const string = 'JavaScript';
const object = { a: 1, b: 2 };
```



- 메모리 사용 : 메모리를 사용하다는 것은 메모리를 읽고 쓰는 것을 의미합니다. 메모리가 할당된 변수를 사용하면 읽기와 쓰기 작업이 이루어집니다.



- 메모리 해제 : 더 이상 필요하지 않는 메모리를 해제하여 재사용 할 수 있도록 합니다.
  - 보통 저수준의 언어에서는 메모리가 필요 없어질 때 개발자가 명시적으로 메모리를 해제해야 하지만 자바스크립트와 같은 고수준의 언어에서는 **가비지 컬렉션**이라는 자동 메모리 관리 방법을 사용합니다.



### 메모리 생명주기 예시

```javascript
function add() {
  const one = 1;
  const two = 2;
  const sum = one + two;
  
  return sum;
}
```

- 메모리 할당 : add 함수를 실행하면 함수 내부에서의 지역 변수 one, two, sum이 생성 됩니다. 이 시점에서는 변수의 값을 저장할 메모리가 할당됩니다.
- 메모리 사용 : 함수를 실행하면 생성된 지역 변수들이 사용됩니다.
- 메모리 해제 : 지역 변수는 함수 내부에서만 사용가능하므로 함수가 종료되면 one, two, sum은 더 이상 필요하지 않게 됩니다. 따라서 해당 변수를 할당했던 메모리를 회수하여 재사용 할 수 있도록 해야 합니다.



## 가비지 컬렉터의 2가지 방법

- 가비지 컬렉터는 어떤 변수가 사용되지 않는지 추적해야 메모리 회수가 가능합니다. 



### 1. Reference Counting

- 널리 쓰이는 방법은 아니지만 레퍼런스 카운팅이라고 불리는 가바지 컬렉션 방식은 해당 값이 얼마나 참조되었는지 추적한다는 것입니다.
- 가비지 컬렉터는 레퍼런스 카운트가 0인 값에서 사용하던 메모리를 회수합니다.

```javascript
// 참조 카운트 : 1
let objectA = {};	
// 참조 카운트 : 2
let objectB = objectA; 

// 참조 카운트 : 1
objectA = null;
// 참조 카운트 : 0 => G.C 대상
objectB = null; 
```



### 문제점 : 순환 참조 문제

- 레퍼런스 카운팅 방식은 넷스케이프 네비게이터 3.0에서 처음 사용되었는데 순환 참조라는 심각한 문제가 발생했다고 합니다.

```javascript
// 객체가 서로 참조하는 경우
// objectA 와 objectB의 참조 카운트는 2가 됩니다.
function fc() {
  const objectA = {};
  const objectB = {};
  
  objectA.otherObject = objectB;
  objectB.anotherObject = objectA;
}
```

- 함수 실행이 끝나면 두 객체는 스코프를 벗어나게 될 것이고 두 객체는 불필요해지므로 할당된 메모리가 회수되어야 합니다. 하지만 레퍼런스 카운팅 방식에서는 함수실행이 끝난 뒤에도 레퍼런스 카운트가 2이므로 두 객체는 계속 존재하게 됩니다.
- 결국 메모리를 회수하지 못하고 낭비되는 메모리가 늘어나게 됩니다. 이것을 방지하고자 **넷스케이프 4.0** 버전에서는 **마크 앤 스위프** 방식을 사용합니다.



### 2. Mark and sweep

- 자바스크립트에서 가장 널리 사용되는 가바지 컬렉션 방식입니다.
- 마크 앤 스위프 알고리즘은 메모리 해제 여부를 결정하기 위해 루트(root)부터 해당 객체까지 닿을 수 있는지 판단하게 됩니다. 여기서 루트는 자바스크립트의 **window 객체**를 의미합니다.
- 가비지 컬렉터는 루트부터 시작해서 루트가 참조하는 객체들, 그 객체가 참조하는 또 다른 각 객체들을 추적하게 됩니다. 겍체를 추적하면서 닿을 수 있는 객체는 **표시(mark)** 한 후, 표시가 없는 객체들은 메모리를 **해제(sweep)**합니다.
- 2012년 기준으로 최산 브라우져들이 많이 사용하고 있습니다.
- 순환 참조 문제도 해결할 수 있습니다.



# 자바스크립트의 메모리 관리

- 웹 브라우저에서 사용할 수 있는 메모리는 일반적으로 PC의 가상메모리에 비해 매우 적습니다.
- 적은 메모리만 할당받는 주된 이유는 웹 페이지에서 실행하는 자바스크립트가 시스템 메모리를 전부 사용해서 운영체제를 다운 시키는 일을 방지하기 위함이라고 합니다.
- 메모리 제한은 변수 할당 뿐만 아니라 호출 스택, 스레드에서 실행할 수 있는 문장 수에도 영향을 미칩니다.
- 그래서 가능한 최소한의 메모리만 사용해야 **페이지 성능**을 높일 수 있습니다. 



### 1. 코드 실행에 필요한 데이터만 유지하자!

- 필요 없어진 데이터에는 null을 할당해서 참조를 제거하는게 좋습니다. 수동으로 참조를 제거해야 할 대상은 주로 **전역변수** 입니다. **지역 변수**는 컨텍스트를 빠져나가는 순간 자동으로 참조가 제거되기 때문입니다.

```javascript
function create(v) {
  const ob = {};
  
  ob.v = v;
  
  return ob;
}

let a = create('value');

a = null;
```

- create 함수가 실행을 끝내는 순간 **지역 변수** **ob**는 컨텍스트를 벗어나므로 명시적으로 참조를 제거할 필요가 없습니다. 하지만 **a**는 **전역 변수**이므로 필요 없어진 순간에 마지막 줄과 같이 직접 참조를 제거해야 합니다.
- 변수에서 참조를 제거하는 것이 할당된 메모리를 자동으로 반환하는 것이 아닙니다. 참조 제거를 통해 값의 컨텍스트를 제거래서 다음에 가비지 컬렉션을 실행할 때 해당 메모리를 회소하도록 하기 위함입니다.